/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2022 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "stdio.h"



/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

#ifdef __GNUC__
/* With GCC/RAISONANCE, small printf (option LD Linker->Libraries->Small printf set to 'Yes') calls __io_putchar() */
#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
#else
#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
#endif /* __GNUC__ */
//?��printf ?��?���??? ?��?��?���??? ?��?�� ?��로토???��

#define MYZERO GPIO_PIN_RESET
#define MYONE GPIO_PIN_SET

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
TIM_HandleTypeDef htim4;

UART_HandleTypeDef huart2;

/* USER CODE BEGIN PV */
TIM_HandleTypeDef htim4; //?��???���??? 4 ?��?��... ?���????

UART_HandleTypeDef huart2; //?��UART2 ?��?��. PCOM?�� ?��?��?��?��?��



uint8_t utx[16]; //?��tx?�� 16개의 ?��?��?�� 배열
uint8_t urx[16]; //?��rx?�� 16개의 ?��?��?�� 배열

char SPI_TICK_1 = 'n'; //?��1?? ?��?���??? ?��?��?�� �???
char SPI_TICK_2 = 'n'; //?��2?�� rising edge
char SPI_TICK_3 = 'n'; //?��3?? ?���??? ?��?��?�� �???
char SPI_TICK_4 = 'n'; //?��4?�� falling edge
char SPI_CS_HIGH = 'n'; //?��Chip Select�??? High?���????��?... ?��?��?��
char SPI_CS_LOW = 'n'; //?��Chip Select�??? Low?���????��?... ?��?��?��
char SPI_CLK_HIGH = 'n'; //?��CLK�??? High?���????��?... ?��?��?��
char SPI_CLK_LOW = 'n'; //?��CLK�??? Low?���????��?... ?��?��?��
char SPI_DI_LOAD = 'n'; //?��DI_LOAD... ?��?��?��
char SPI_DO_CHECK = 'n'; //?��DO ?��?��... ?��?��?��
char SPI_BREAK = 'n'; //?��SPI BREAK... ?��?��?��

int tim4Cnt; //?��???���??? 카운?��(?��?��)
int SPI_on = 0; //?��SPI - ON = 0 (0?�� 무슨 ?��미일�????)
int SPI_BitCnt = 0; //?��BPI 비트 카운?�� = 0... ?���??? ?���??? ORG ?��?�� 비트 �????���??? ?���??? �??? ?��?��?�� 걸�??��?... 모르겠다.

char pc13flag; //?��pc13flag... STM?�� ?��?? 버튼?�� 말한?��



/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_TIM4_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */


PUTCHAR_PROTOTYPE
{
	/* Place your implementation of fputc here */
	/* e.g. write a character to the USART2 and Loop until the end of transmission */
	HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, 0xFFFF);
	return ch;
} //?��printf�??? ?��?��?�� uart2�??? ?��?��?���??? ?��보내?�� ?��로토???��

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	//?�� ???���??? ?��?�� 코드
	if(htim->Instance == htim4.Instance){
		//?��?���작?��?�� ???��머�? ???���??? 4?���???
		// test pin
		HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_1); // test
		//?��A1?�� ?���????��?��.
		if(1 == SPI_on){
			//?��?���SPI_on?�� 1?��?���???... 그런?�� 초기�??? SPI_on?? 0?��?��. ?���??? �???분에?�� SPI_on?�� ?��?��?���??? ?��?��.
			tim4Cnt += 1;//?��???���??? 카운?���??? 1 ?��?��?��
			if((tim4Cnt % 4) == 1){
				//?��?���tim counter ... 1?��?���???...
				SPI_TICK_1 = 'y'; //?��?��?���??? ?��?��?�� CLK
			}
			if((tim4Cnt % 4) == 2){
				//?��?��? 카운?���??? 2?���???
				SPI_TICK_2 = 'y'; //?��?��?�� ?���???
			}
			if((tim4Cnt % 4) == 3){
				//?��?��? 카운?���??? 3?��?���???
				SPI_TICK_3 = 'y'; //?�� ?���??? ?��?��?�� ?���???
			}
			if((tim4Cnt % 4) == 0){
				//?��?��? 카운?���??? 4?���???
				SPI_TICK_4 = 'y'; //?��?���??? ?���???
				tim4Cnt = 0; //?��???���??? 카운?�� 초기?��... ?��?�� 0�????�� ?��?��
			}
		}
	}
} //?�� ?��? ?��체적?�� 추론 결과 ???��머는 CLK�??? 만들기만 ?�� �??? ?���??? ?��과는 ?��?��?�� ?��?��

int setCS(int PinState){
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, PinState);
	return 0;
}
int setCLK(int PinState){
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, PinState);
	return 0;
}
int setDI(int PinState){
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, PinState);
	return 0;
}




int spi_93c56c_EWEN(void)
{
	//?��SPI-93C56C?�� E/W -ENable 코드... ?��?�� ?��로토???��?�� ?��?��?���??? ?��?��?��?���??? ?��?��?��?�� ?��출하?�� 것으�??? 보임
	int SPI_DI_OUTPUT = 0x0980; //?��SPI-DI?�� 0x0980?�� 보냄. ?��?�� Slave?�� DI?�� 마스?��?�� 출력?�� (반�??��?��)
	int SPI_Data_Cnt = 12; //?��?��?��?�� 카운?��?�� 12... ?��?�� 비트 카운?��?? ?��르게 ?��코프 ?���????��?�� ?��?��?��?�� 코드?��
	int SPI_Data_Comp = 0x0800; //?��?��?��?�� Compare? ?��?��. 0x0800?�� �???

	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_RESET); // CS
	//?��A9?�� ?��?��?�� ?���???. CS�??? A9?��?��
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_RESET); // CLK
	//?��A10?�� ?��?��?�� ?���???. CLK�??? A10
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_RESET); // DI
	//?��B8?�� ?��?��?�� ?���???. DI�??? B8?��?��
	//HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9, GPIO_PIN_RESET); // DO
	//?��?��?�� 코드?�� ?��?�� 주석처리�??? DO???�� ?��미하?��?��. ?�� 그런?�� Slave?�� Output?? Master�??? 무조�??? ?��?��?�� ?��?��?�� ?�� ???�� ?????


	//?�� ?��? ?��?�� ?��체적?�� 코드?�� ?��명서?��?�� 보았?�� CLK?? CS, DI�??? ?���??? 1?�� 경우, Start Condition?��?��?�� 말과 같�? 것으�??? 보인?��.

	SPI_TICK_1 = 'n'; //?��?��?���??? ?��?��?���????��?... ?��?��?��
	SPI_TICK_2 = 'n'; //?��?��?�� ?���????���????��?... ?��?��?��
	SPI_TICK_3 = 'n'; //?��?���??? ?��?��?���????��?... ?��?��?��
	SPI_TICK_4 = 'n'; //?��?���??? ?���????���????��?... ?��?��?��
	SPI_CS_HIGH = 'n'; //?��CS�??? High?���????��?... ?��?��?��
	SPI_CS_LOW = 'n'; //?��CS�??? Low?���????��?... ?��?��?��
	SPI_CLK_HIGH = 'n'; //?��CLK�??? High?���????��?... ?��?��?��
	SPI_CLK_LOW = 'n'; //?��CLK�??? Low?���????��?... ?��?��?��
	SPI_DI_LOAD = 'n'; //?��DI Load?���????��?... ?��?��?��
	SPI_DO_CHECK = 'n'; //?��DO ?��?��?���????��?... ?��?��?��
	SPI_BREAK = 'n'; //?��SPI�??? break?��?��?��?��?... ?��?��?��

	SPI_BitCnt = 0; //?��?��?�� 비트 카운?��?�� 0
	tim4Cnt = 0; //?��???���??? 카운?��?�� 0. (CLK�??? 초기?�� ?�� 것으�??? 보임)
	SPI_on = 1; //?��SPI�??? 켜짐. ?��?��?�� ???���??? ?��?��?�� ?��?�� ?�� 것으�??? 보임. ???��머는 SPI-on == 1?��?���??? ?���의미있?�� ?��?��?�� ?��


	/*
		?�� ?�� 코드 ?��?��. Start Condition?�� 주겠?��. (?��근데 RESET?��?��?�� ?��???�� 컨티?��?�� ?�� 주는 �??? ?�� ?�� ?��?��?��)
		?�� 모든 값을 초기?��?��겠다.
		?�� SPI?�� ?��?��?��?��.
	*/

	while(1){
		//?��while?? ?��?��?�� ?��?��?�� (�????�� ?��?��?�� spi break?��?�� break 코드�??? 만날 ?�� 까�?.)

		//?��?��기서 물어보는 SPI_TICK_1..2..3..4?�� ???��머에?�� 계속 바�?�고 ?��?��.
		//?��추�?�??? ?��?��?��건데, ???��머는 ?��?��?��?��마자 1?�� ?��?���??? TICK?�� 체크?���??? ?��문에 ?��?��?���??? ?��?��?�� 값에?�� 1?�� 빼주?��?�� ?��?��.
		//?��0?��?�� �??? CLK(?��?���??? ?��?��)?�� ?��
		if('y' == SPI_TICK_1){//?��?
			//?��?����??��머�? TICK-1?�� yes�??? 만들?��
			SPI_TICK_1 = 'n'; //?��?��?�� SPI_TICK_1?�� n?���??? 만들?��. 그러고보?�� ?�� ???��머는 ?�� yes�??? 만들�??? ?��망만 �???. ?��처리?�� ?��기서 ?��?��?��
			SPI_BitCnt += 1; //?�� 비트 카운?���??? 1 ?��?��갔다.
			if(1 == SPI_BitCnt){
				//?��?���비?�� 카운?���??? 1?��?���???...
				SPI_CS_HIGH = 'y'; //?��CS High�??? yes�??? ?��?��.
			}
			if((SPI_Data_Cnt + 1) == SPI_BitCnt){ //?��?
				//?��?���SPI-data-cnt?�� ?���??? �????���??? ?��기서?�� 값�? 13. BitCnt�??? 13?�� ?�� ?�� 까�? ?��?��?���??? ?��?�� 코드
				SPI_CS_LOW = 'y'; //?��CS Low�??? yes�??? ?��?��
				SPI_BREAK = 'y'; //?��SPI break�??? yes�??? ?��?��
			}
			if((1 <= SPI_BitCnt) && (SPI_BitCnt <= SPI_Data_Cnt)){
				//?��?��? 비트 카운?���??? 1보다 ?��거나 같고... ?���??? ?��?���????�� ?��거나 같을?��. ?��?�� 조건?�� 0?���???, 코드�??? ?��?��?��?��마자 1?�� ?��?���????���???.
				//?��?��? 게다�???... 비트 카운?���??? ?��?��?�� 카운?��보다 ?��거나 같다�???... (?��?)�??? ?���??? ?��까�? 계속 ?��립하?�� 코드
				SPI_DI_LOAD = 'y'; //?��DI Load?�� Yes!
			}
		}//?��?
		if('y' == SPI_TICK_2){
			//?��?���TICK2�??? YES?���????
			SPI_TICK_2 = 'n'; //?��TICK2?�� no
			if((1 <= SPI_BitCnt) && (SPI_BitCnt <= SPI_Data_Cnt)){
				//?��?���비?�� 카운?���??? 1보다 ?��거나 같고... 비트 카운?���??? ?��?��?�� 카운?��보다 ?��거나 같다�????
				SPI_CLK_HIGH = 'y'; //?��CLK?�� high!
			}
		}
		if('y' == SPI_TICK_3){
			//?��?��? TICK-3�??? yes?���????
			SPI_TICK_3 = 'n'; //?��TICK3?�� no (?���??? ?��?��?? ?��무것?�� ?��?��)
		}
		if('y' == SPI_TICK_4){
			//?��?���TICK-4�??? yes?���????
			SPI_TICK_4 = 'n'; //?��TICK4?�� no
			if((1 <= SPI_BitCnt) && (SPI_BitCnt <= SPI_Data_Cnt)){
				//?��?���위?��?�� 비슷?���??? ?���??? 많음.
				//?��?���비?�� 카운?���??? 1보다 ?���???... 게다�??? 비트 카운?���??? ?��?��?�� 카운?��보다 ?��거나 같다�???...
				SPI_CLK_LOW = 'y'; //?��CLK - Low?�� Yes!
			}
		}

		if('y' == SPI_CS_HIGH){
			//?��?���CS High?���????��?... Yes!
			SPI_CS_HIGH = 'n'; //?��cs high?�� no
			//--- 코드 추�? --- // CS:1

			setCS(MYONE); //?��?���내코드!

		}else if('y' == SPI_CS_LOW){
			//?��?���CS Low?���????��?... yes
			SPI_CS_LOW = 'n'; //?�� cs low?�� no
			//--- 코드 추�? --- // CS:0
			setCS(MYZERO); //?��?���내코드!
		}

		if('y' == SPI_CLK_HIGH){
			//?��CLK High?���????��?... yes
			SPI_CLK_HIGH = 'n'; //?��CLK High?�� no
			//--- 코드 추�? --- // CLK:1
			setCLK(MYONE); //?��?���내코드!
		}else if('y' == SPI_CLK_LOW){
			//?��CLK Low?���????��?... yes
			SPI_CLK_LOW = 'n'; //?��CLK Low?�� no
			setCLK(MYZERO); //?��?���내코드!
			//--- 코드 추�? --- // CLK:0
		}

		if('y' == SPI_DI_LOAD){
			//?��DI Load�??? yes?���???...
			SPI_DI_LOAD = 'n'; //?��DI Load?�� no
			if((SPI_DI_OUTPUT & SPI_Data_Comp) == SPI_Data_Comp){
				//?��만약?�� DI_Output�??? Data 비교?�� 비트 AND�??? Data Comp?? 같다�???...
				setDI(MYONE); //?��?���내코드!

				//--- 코드 추�? --- // DI:1
			}else{
				//?��같�? ?��?���???
				setDI(MYZERO); //?��?���내코드!
				//--- 코드 추�? --- // DI:0
			}


			SPI_Data_Comp >>= 1;//?��?��?��?�� 비교 �????���??? ?��른쪽?���??? ?�� �??? �????��
		}

		if('y' == SPI_BREAK){
			//?��spi break�??? yes?���????
			SPI_BREAK = 'n'; //?��spi break?�� no.
			SPI_on = 0; //?��spi _on?? 0?�� ?��?��.
			break; //?��while 종료
		}
	}

	return(0); //?��EWEN?�� 종료
} //end of ewen


int spi_93c56c_WRITE(int SPI_ADDR, int SPI_DATA_WRITE)
{
	//?��WRITE?�� 주소?? ?��?��?���??? ?��?��메터�??? 받는?��.
	int SPI_DI_OUTPUT = 0x0A0000 + (SPI_ADDR << 8) + SPI_DATA_WRITE;
	//?��?��?��?�� ?��?��?��(DI�??? 보낼 �???)?? 0x0A0000?�� (주소�??? ?��쪽으�??? 8�??? ?��?��?��?�� �???) + ?��?��?���??? ?��?��.
	int SPI_Data_Cnt = 20; //?��?��?��?�� 카운?��?�� 20. ?��번엔 �??? 길다
	int SPI_Data_Comp = 0x80000; //?��비교 ?��?��?��?�� 0x80000

	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_RESET); // CS ?��CS RESET
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_RESET); // CLK ?��CLK RESET
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_RESET); // DI ?��DI RESET
	//HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9, GPIO_PIN_RESET); // DO

	//?��?��?? 같아보임. ?��?��?�� 초기?��

	SPI_TICK_1 = 'n'; //?��?��?���??? ?��?��?���????��?... ?��?��?��
	SPI_TICK_2 = 'n'; //?��?��?�� ?���????���????��?... ?��?��?��
	SPI_TICK_3 = 'n'; //?��?���??? ?��?��?���????��?... ?��?��?��
	SPI_TICK_4 = 'n'; //?��?���??? ?���????���????��?... ?��?��?��
	SPI_CS_HIGH = 'n'; //?��CS�??? High?���????��?... ?��?��?��
	SPI_CS_LOW = 'n'; //?��CS�??? Low?���????��?... ?��?��?��
	SPI_CLK_HIGH = 'n'; //?��CLK�??? High?���????��?... ?��?��?��
	SPI_CLK_LOW = 'n'; //?��CLK�??? Low?���????��?... ?��?��?��
	SPI_DI_LOAD = 'n'; //?��DI Load?���????��?... ?��?��?��
	SPI_DO_CHECK = 'n'; //?��DO ?��?��?���????��?... ?��?��?��
	SPI_BREAK = 'n'; //?��SPI�??? break?��?��?��?��?... ?��?��?��

	SPI_BitCnt = 0; //?��비트카운?��?�� 0�????��
	tim4Cnt = 0; //?��카운?��?�� 0�????��
	SPI_on = 1; //?��SPI�??? on!

	while(1){
		if('y' == SPI_TICK_1){
			//?��?���tick1 yes?���???
			SPI_TICK_1 = 'n'; //?��tick1 no
			SPI_BitCnt += 1; //?��비트 카운?�� 1 증�?
			if(1 == SPI_BitCnt){ //?��비트 카운?���??? 1?��?���???
				SPI_CS_HIGH = 'y'; //?�� cs high�??? yes!
			}
			if((SPI_Data_Cnt + 1) == SPI_BitCnt){
				//?��?���데?��?�� 카운?��+1 (?��기서?�� 21)?�� 비트 카운?��?? 같다�???
				SPI_CS_LOW = 'y'; //?�� cs low �??? yes�??? ?��?��
				SPI_BREAK = 'y'; //?�� spi break?��?�� yes (종료?��?��?��)
			}
			if((1 <= SPI_BitCnt) && (SPI_BitCnt <= SPI_Data_Cnt)){
				//?��?���비?�� 카운?���??? 1보다 ?���???... 게다�??? 비트 카운?���??? ?��?��?�� 카운?��보다 ?��거나 같을 ?��
				SPI_DI_LOAD = 'y'; //DI Load�??? yes�??? ?��
			}
		}
		if('y' == SPI_TICK_2){
			//?��?���tick2�??? yes?���???
			SPI_TICK_2 = 'n'; //?��tick2�??? no�??? ?��?��
			if((1 <= SPI_BitCnt) && (SPI_BitCnt <= SPI_Data_Cnt)){
				//?��?���만?�� 비트 카운?���??? 1보다 ?���???... 게다�??? 비트 카운?���??? ?��?��?�� 카운?��보다 ?��거나 같을 ?��
				SPI_CLK_HIGH = 'y'; //?��CLK High?�� yes!

			}
		}
		if('y' == SPI_TICK_3){
			//?��?���tick3�??? yes?���???
			SPI_TICK_3 = 'n'; //?��tick3?�� no?��?��?��. ?�� ?��?�� ?��?��?? ?��?��.
		}
		if('y' == SPI_TICK_4){
			//?��?���tick4�??? yes?���???
			SPI_TICK_4 = 'n'; //?��tick4?�� no
			if((1 <= SPI_BitCnt) && (SPI_BitCnt <= SPI_Data_Cnt)){
				//?��?���비?�� 카운?���??? 1보다 ?��거나... 게다�??? 비트 카운?���??? ?��?��?�� 카운?��보다 ?��거나 같다�???
				SPI_CLK_LOW = 'y'; //?��CLK Low?�� yes...
			}
		}

		if('y' == SPI_CS_HIGH){ //?��?���CS High yes?���???
			SPI_CS_HIGH = 'n'; //?��CS High no�??? ?��?��
			setCS(MYONE); //?��?���내코드!
			//--- 코드 추�? --- // CS:1
		}else if('y' == SPI_CS_LOW){
			//?��?���CS Low�??? yes?���???
			SPI_CS_LOW = 'n';
			//?��CS Low?�� no

			setCS(MYZERO); //?��?���내코드!

			//--- 코드 추�? --- // CS:0
		}

		if('y' == SPI_CLK_HIGH){
			//?��?���CLK High�??? Yes?���???
			SPI_CLK_HIGH = 'n'; //?��CLK high?�� no

			setCLK(MYONE); //?��?���내코드!

			//--- 코드 추�? --- // CLK:1
		}else if('y' == SPI_CLK_LOW){
			//?��?���CLK Low�??? yes?���???
			SPI_CLK_LOW = 'n'; //CLK low?�� no

			setCLK(MYZERO); //?��?���내코드!

			//--- 코드 추�? --- // CLK:0
		}

		if('y' == SPI_DI_LOAD){
			//?��?���DI - Load�??? yes?���???
			SPI_DI_LOAD = 'n'; //?��DI Load?�� no
			if((SPI_DI_OUTPUT & SPI_Data_Comp) == SPI_Data_Comp){
				//?��?���DI Output�??? DataComp?�� 비트 AND�??? DataComp?? 같다�???


				setDI(MYONE); //?��?���내코드!



				//--- 코드 추�? --- // DI:1
			}else{
				//?��?���아?��?���???

				setDI(MYZERO); //?��?���내코드!

				//--- 코드 추�? --- // DI:0
			}
			SPI_Data_Comp >>= 1; //?��?��?��?�� 비교기�?? ?��른쪽?���??? ?�� 비트 �????��
		}

		if('y' == SPI_BREAK){
			//?��?���SPI break�??? yes?���???
			SPI_BREAK = 'n'; //?��spi break = no�??? ?��?��.
			SPI_on = 0; //?��spi on?�� 0. spi 꺼짐
			break; //?��while ?���???
		}
	}

	return(0); //?��?��?��?���??? 종료?�� 0 반환
}//end of write


int spi_93c56c_READ(int SPI_ADDR, int* SPI_DATA_READ)
{
	int SPI_DI_OUTPUT = 0x0C00 + SPI_ADDR; //?��DI�??? 보내?�� 값�?... 0x0C00 + 주소값을 ?��?�� �???
	int SPI_DO_INPUT = 0; //?��DO?��?�� 받는 값�?... 0
	int SPI_Data_Cnt = 12; //?��?��?��?�� 카운?��?�� 12
	int SPI_Data_Comp = 0x800; //?�� ?��?��?�� 비교 - 0x800
	int SPI_Data_IN = 8; //?��?��?��?�� 받기 = 8 ?���????


	int iwishallbefine = 0;

	GPIO_PinState pb9pin; //?��b9?? ?��?�� �????���??? ?��?��?��?��?��

	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_RESET); // CS ?��CS RESET
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_RESET); // CLK ?��CLK RESET
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_RESET); // DI ?��DI RESET

	//HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9, GPIO_PIN_RESET); // DO

	//?��?��?? 같아보임. ?��?��?�� 초기?��

	SPI_TICK_1 = 'n'; //?��?��?���??? ?��?��?���????��?... ?��?��?��
	SPI_TICK_2 = 'n'; //?��?��?�� ?���????���????��?... ?��?��?��
	SPI_TICK_3 = 'n'; //?��?���??? ?��?��?���????��?... ?��?��?��
	SPI_TICK_4 = 'n'; //?��?���??? ?���????���????��?... ?��?��?��
	SPI_CS_HIGH = 'n'; //?��CS�??? High?���????��?... ?��?��?��
	SPI_CS_LOW = 'n'; //?��CS�??? Low?���????��?... ?��?��?��
	SPI_CLK_HIGH = 'n'; //?��CLK�??? High?���????��?... ?��?��?��
	SPI_CLK_LOW = 'n'; //?��CLK�??? Low?���????��?... ?��?��?��
	SPI_DI_LOAD = 'n'; //?��DI Load?���????��?... ?��?��?��
	SPI_DO_CHECK = 'n'; //?��DO ?��?��?���????��?... ?��?��?��
	SPI_BREAK = 'n'; //?��SPI�??? break?��?��?��?��?... ?��?��?��

	SPI_BitCnt = 0; //?��비트카운?��?�� 0�????��
	tim4Cnt = 0; //?��카운?��?�� 0�????��
	SPI_on = 1; //?��SPI�??? on!

	while(1){
		//?��break ?��까�? ?��?��

		if('y' == SPI_TICK_1){
			//?��Tick1?�� yes?���???
			SPI_TICK_1 = 'n'; //?��tick 1 no�??? ?��?��
			SPI_BitCnt += 1; //?��비트 카운?�� 1증�? (맨날 ?��같네)
			if(1 == SPI_BitCnt){
				//?��비트 카운?���??? 1?��?���???
				SPI_CS_HIGH = 'y'; //?��CS high�??? yes�??? ?��
			}
			if((SPI_Data_Cnt + SPI_Data_IN + 1) == SPI_BitCnt){
				//?��?��?��?�� 카운?�� + ?��?��?�� ?��?�� + 1 ..21?�� 비트 카운?��?? 같다�???
				SPI_CS_LOW = 'y'; //?��CS low?�� yes
				SPI_BREAK = 'y'; //?��spi?�� break. 꺼�??��?��
			}
			if((1 <= SPI_BitCnt) && (SPI_BitCnt <= SPI_Data_Cnt)){
				//?��비트 카운?���??? 1보다 ?��거나 같고... 게다�??? 비트 카운?���??? ?��?��?�� 카운?��보다 ?��거나 같다�???
				SPI_DI_LOAD = 'y'; //?��DI Load?�� yes
			}
		}
		if('y' == SPI_TICK_2){
			//?��Tick2?�� yes?���???
			SPI_TICK_2 = 'n'; //?��tick2 no�??? ?��?��
			if((1 <= SPI_BitCnt) && (SPI_BitCnt <= (SPI_Data_Cnt + SPI_Data_IN))){
				//?��비트 카운?���??? 1보다 ?��거나 같고... 게다�??? 비트 카운?���??? ?��?��?�� 카운?�� + ?��?��?�� ?��?��(?��기선 20)보다 ?��거나 같다�???
				SPI_CLK_HIGH = 'y'; //?��CLK High�??? yes�??? ?��?��
			}
		}
		if('y' == SPI_TICK_3){
			//?�� tick3�??? yes?���???
			SPI_TICK_3 = 'n'; //?��tick3?�� no. ?��?�� 맨날 ?��?��?�� ?��?��
		}
		if('y' == SPI_TICK_4){
			//?��tick4�??? yes?���???
			SPI_TICK_4 = 'n'; //?��tick4?�� no.
			if((1 <= SPI_BitCnt) && (SPI_BitCnt <= (SPI_Data_Cnt + SPI_Data_IN))){
				//?��비트 카운?���??? 1보다 ?��거나 같고... 게다�??? 비트 카운?���??? ?��?��?�� 카운?��+?��?��?�� ?��?��(?��기선 20)보다 ?��거나 같다�???
				SPI_CLK_LOW = 'y'; //?��CLK Low?�� yes
			}
			if((SPI_Data_Cnt < SPI_BitCnt) && (SPI_BitCnt <= (SPI_Data_Cnt + SPI_Data_IN))){
				//?��?��?��?�� 카운?���??? 비트 카운?��보다 ?���???, 비트 카운?���??? (?��?��?�� 카운?��+?��?��?�� ?��?�� (?��기선 20)) 보다 ?��거나 같다�???
				SPI_DO_CHECK = 'y'; //?��Do Check�??? yes�??? ?��?�� (?��?)

				/*

					?��?�� 코드?�� ?��?�� ?��?? �????���??? ?��?��?�� 카운?��보다 많고, (bitcnt?�� ?��?��까�? ?��?? �????���??? ?���???)

					DataCnt?�� 고정?�� 길이?��.
					그러?���???... ?��?��?�� 비트�??? ?��?��?�� 카운?���??? ?��?��?���???�???, ?��?��?�� 카운?��+?��?��?�� ?��?��?��기�?? ?��?��?���??? 못했?���??? ?�� 코드�??? ?��출된?��

				*/
			}
		}

		if('y' == SPI_CS_HIGH){
			//?��CS High�??? Yes?���???
			SPI_CS_HIGH = 'n'; //?��cs high?�� no�??? ?��?��
			setCS(MYONE);
			//--- 코드 추�? --- // CS:1
		}else if('y' == SPI_CS_LOW){
			//?��cs low�??? yes?���???
			SPI_CS_LOW = 'n'; //?��cs low?�� no�??? ?��?��
			setCS(MYZERO);
			//--- 코드 추�? --- // CS:0
		}

		if('y' == SPI_CLK_HIGH){
			//?��clk high�??? yes?���???
			SPI_CLK_HIGH = 'n'; //?��clk high?�� no
			setCLK(MYONE);
			//--- 코드 추�? --- // CLK:1
		}else if('y' == SPI_CLK_LOW){
			//?��clk low�??? yes?���???
			SPI_CLK_LOW = 'n'; //?��clk low?�� no
			setCLK(MYZERO);
			//--- 코드 추�? --- // CLK:0
		}

		if('y' == SPI_DI_LOAD){
			//?��di load�??? yes?���???
			SPI_DI_LOAD = 'n'; //?��di load = no
			if((SPI_DI_OUTPUT & SPI_Data_Comp) == SPI_Data_Comp){
				//?��?��?��?�� 보냄�??? ?��?��?�� 비교?�� 비트 AND�??? ?��?��?�� 비교?? 같다�???...
				setDI(MYONE);
				//--- 코드 추�? --- // DI:1
			}else{
				//printf("%d\r\n", HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_9));
				setDI(MYZERO);
				//--- 코드 추�? --- // DI:0
			}
			//?��?��?��?�� 비교�??? ?��른쪽?���??? ?�� 비트 민다
			SPI_Data_Comp >>= 1;
		}

		if('y' == SPI_DO_CHECK){
			//?�� SPI Do check�??? yes?���???... ?���에?�� ?��?��
			SPI_DO_CHECK = 'n';
			pb9pin = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_9);
			if(pb9pin == GPIO_PIN_SET){
				SPI_DO_INPUT = SPI_DO_INPUT + (0x80 >> iwishallbefine);

			}
			iwishallbefine++;

			//--- 코드 추�? ---

			HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_1); // test
			//?��C1???�� ?���????��. ?���??? 뭐�??
		}

		if('y' == SPI_BREAK){
			//?��spi break�??? yes?���???.
			SPI_BREAK = 'n'; //?��spi break�??? no�??? ?��?��
			SPI_on = 0; //?��spi on?? 0... 꺼짐
			break; //?��while 종료
		}
	}

	*SPI_DATA_READ = SPI_DO_INPUT; //?��Data Read ?��?��?��?�� Do Input 값을 ?��?��?��

	return(0);
}//end of read

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	//?��NVIC?���??? ?��?��?�� ?��?��?��?���??? 발생?�� ?�� ?��?���??? ?��출함
	if(GPIO_Pin == GPIO_PIN_13){
		//?��GPIO_pin?�� 13?��?���???
		if('n' == pc13flag){ //?��그런?�� 13flag�??? no?���????...

			pc13flag = 'y'; //?��13flag?�� yes�??? ?��
			printf("-----pc13flag = %c-----\r\n",pc13flag); //?��13 flag?�� (13flag?�� �???)?��?��?��!�??? ?��?��?��

			//?��?��?���??? ?��?��?�� 13flag?�� yes?�� 것임...
		}
	}

}









/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */
	HAL_StatusTypeDef tim4it; //?��tim4 ?��?��?��?���??? �????��
	HAL_StatusTypeDef uart2state; //?��uart2 ?��?�� �????��
	int retvalue; //?��??? ?���??? 뭘까
	//GPIO_PinState pc13pin;
	int spi_read; //?��spi ?��?? �??? �????��. 비어?��?��
  /* USER CODE END 1 */
  

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_USART2_UART_Init();
  MX_TIM4_Init();
  /* USER CODE BEGIN 2 */
	printf("---93c56c spi(gpio) TEST---\r\n"); //?��SPI ?��?��?��... 그냥 코드 ?��?�� ?��?��?�� ?��?��

	tim4it = HAL_TIM_Base_Start_IT(&htim4); //?��???���???4�??? ?��?��?���??? 반환값을 tim4it?�� ?��?��
	if(HAL_OK == tim4it){
		//?��tim4it?�� HAL_OK?���????...
		printf("HAL_TIM_Base_Start_IT=%d OK\r\n",tim4it); //?��???���??? OK!
	}else{
		printf("HAL_TIM_Base_Start_IT=%d error\r\n",tim4it); //?��???���??? error.
	}

	SPI_on = 0; //?��spi-on?? 0?��?�� (spi�??? 켜졌?���??? ?��?��?��?�� �????��)
	tim4Cnt = 0; //?��tim4Cnt?�� 0?��?��. (CLK?�� 만드?�� �????��)

	pc13flag = 'n';//?�� 초기 13flag?�� no?��?��?��
  /* USER CODE END 2 */
 
 

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */



		//?��while?? ?��?��?�� 반복?��?��?��... 브레?��?�� ?��?��

	  uart2state = HAL_UART_Receive(&huart2, urx, 3, 500);
		//?��uart2state?�� uart2?��?�� 값을 받아?��. ?���??? ?��?�� 3, 500?? 3�????���??? 받고, 500ms ?��?�� ???��?��?��... urx?�� ?��?��?��. ?��?��?��?��
	  if(HAL_OK == uart2state){
			//?��uart2state�??? HAL_OK?���???
		  if('w' == urx[0]){ // 0x77='w'
				//?��?��?�� urx 첫번�??? 값이 0x77(w)?���????��?...
			  retvalue = spi_93c56c_EWEN();
				//?��ret value?�� ?��?��?�� 반환값입?��?��. (EWEN?? ?��?�� ?��?��?�� 0 반환)
			  if(0 == retvalue){
					//?��retvalue�??? 0?���????��? (?��?�� ?��?��)
				  //printf("spi_93c56c_EWEN=%d\r\n",retvalue);
					//?��EWEN?�� 0?��?���??? 말하?��?�� �??? 같�??��... 주석처리?��
			  }else{
					//?��0?�� ?��?��?���??? EWEN?? ?��류�? ?��겼을 �???
				  printf("spi_93c56c_EWEN error\r\n");
			  }
			  HAL_Delay(10); //?��10ms기다립시?��
			  retvalue = spi_93c56c_WRITE(urx[1],urx[2]);
				//?��retvalue?�� WRITE?��?���??? ?��?��?�� 결과?��?��?��. ?��?��메터?�� urx?�� ?��번�?? �????��, ?��번째 �????��?��?��?��. (?��?�� ?��?��?�� 0?�� 반환?��?��?��.)
			  if(0 == retvalue){
					//?��retvalue�??? 0?���????��?

				  //printf("spi_93c56c_WRITE=%d\r\n",retvalue);
					//?��WRITE?�� 0?��?��?�� (?��?�� ?��?�� 코드). 주석처리?��?��?��?��.
			  }else{
					//?��retvalue�??? 0?�� ?��?��?���???... (비정?��)
				  printf("spi_93c56c_WRITE error\r\n");
					//?�� error 출력

			  }
			  printf("addr=%3d(0x%02x),write data=%3d(0x%02x)\r\n",urx[1],urx[1],urx[2],urx[2]);
				//?��마�?막에 ?��?��?��?�� printf... urx1?? 주소�??? urx2?�� 값인?��
		  }else if('r' == urx[0]){ // 0x72='r'
				//?��urx 첫�??���??? 0x72(r)?��?���???
			  retvalue = spi_93c56c_READ(urx[1],&spi_read);
				//?��retvalue?�� READ ?��?��?�� 반환�??? (?��?��메터?�� rx1�???, spi_read) ?��?�� ?��?��?�� 0?�� �????��?��?��?�� ?���??? spi_read?�� ???��?��?��?��
			  if(0 == retvalue){
					//?��retvalue�??? 0?��?���??? (?��?�� ?��?��)
				  //printf("spi_93c56c_READ=%d\r\n",retvalue);
					//?��read�??? 0?��?�� 출력... ?���???�??? 주석처리?�� 코드
			  }else{
					//?��retvalue�??? 0?�� ?��?��?���???
				  printf("spi_93c56c_READ error\r\n");
					//?��?��?���??? ?���???

			  }
			  printf("addr=%3d(0x%02x),read data=%3d(0x%02x)\r\n",urx[1],urx[1],spi_read,spi_read);
				//?��최종?��?���??? urx?�� ?��번째 �????��(주소)?��?�� ?��?��?�� �??? spi_read�??? �????��?��?��?��
		  }else if('h' == urx[0]){ //0x68
				printf("?��?��!\r\n");
			}
	  }

	  HAL_Delay(100); //?��100ms 기다립니?��
	  HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5); //?��A5(LED)�??? ?���????��?��?��. LED�??? 깜빡거리겠네?��



  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI_DIV2;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL16;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief TIM4 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM4_Init(void)
{

  /* USER CODE BEGIN TIM4_Init 0 */

  /* USER CODE END TIM4_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM4_Init 1 */

  /* USER CODE END TIM4_Init 1 */
  htim4.Instance = TIM4;
  htim4.Init.Prescaler = 64-1;
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim4.Init.Period = 10-1;
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM4_Init 2 */

  /* USER CODE END TIM4_Init 2 */

}

/**
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{

  /* USER CODE BEGIN USART2_Init 0 */

  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_1, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1|LD2_Pin|GPIO_PIN_9|GPIO_PIN_10, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_RESET);

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : PC1 */
  GPIO_InitStruct.Pin = GPIO_PIN_1;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pins : PA1 LD2_Pin PA9 PA10 */
  GPIO_InitStruct.Pin = GPIO_PIN_1|LD2_Pin|GPIO_PIN_9|GPIO_PIN_10;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /*Configure GPIO pin : PB8 */
  GPIO_InitStruct.Pin = GPIO_PIN_8;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pin : PB9 */
  GPIO_InitStruct.Pin = GPIO_PIN_9;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);

}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{ 
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
